<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<title>daBits and Domain Conversion in MP-SPDZ | Hernán Vanegas</title>
<meta name=keywords content>
<meta name=description content="In secure multi-party computation (MPC), each protocol has an underlying domain of computation in which the secure operations are performed. Such domains of computation are algebraic structures such as fields or rings. Some common examples for those domains are finite fields of order $q$, with $q$ prime, and rings of the form $\mathbb{Z}_{2^k}$. A special case is the field $\mathbb{Z}_2$, which is the one that we refer to as binary domain.">
<meta name=author content>
<link rel=canonical href=http://hdvanegasm.github.io/posts/dabits_and_domain_conversion/dabits/>
<link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://hdvanegasm.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://hdvanegasm.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://hdvanegasm.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://hdvanegasm.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://hdvanegasm.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="daBits and Domain Conversion in MP-SPDZ">
<meta property="og:description" content="In secure multi-party computation (MPC), each protocol has an underlying domain of computation in which the secure operations are performed. Such domains of computation are algebraic structures such as fields or rings. Some common examples for those domains are finite fields of order $q$, with $q$ prime, and rings of the form $\mathbb{Z}_{2^k}$. A special case is the field $\mathbb{Z}_2$, which is the one that we refer to as binary domain.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://hdvanegasm.github.io/posts/dabits_and_domain_conversion/dabits/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2023-10-31T00:00:00+00:00">
<meta property="article:modified_time" content="2023-10-31T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="daBits and Domain Conversion in MP-SPDZ">
<meta name=twitter:description content="In secure multi-party computation (MPC), each protocol has an underlying domain of computation in which the secure operations are performed. Such domains of computation are algebraic structures such as fields or rings. Some common examples for those domains are finite fields of order $q$, with $q$ prime, and rings of the form $\mathbb{Z}_{2^k}$. A special case is the field $\mathbb{Z}_2$, which is the one that we refer to as binary domain.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog posts","item":"http://hdvanegasm.github.io/posts/"},{"@type":"ListItem","position":2,"name":"daBits and Domain Conversion in MP-SPDZ","item":"http://hdvanegasm.github.io/posts/dabits_and_domain_conversion/dabits/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"daBits and Domain Conversion in MP-SPDZ","name":"daBits and Domain Conversion in MP-SPDZ","description":"In secure multi-party computation (MPC), each protocol has an underlying domain of computation in which the secure operations are performed. Such domains of computation are algebraic structures such as fields or rings. Some common examples for those domains are finite fields of order $q$, with $q$ prime, and rings of the form $\\mathbb{Z}_{2^k}$. A special case is the field $\\mathbb{Z}_2$, which is the one that we refer to as binary domain.","keywords":[],"articleBody":"In secure multi-party computation (MPC), each protocol has an underlying domain of computation in which the secure operations are performed. Such domains of computation are algebraic structures such as fields or rings. Some common examples for those domains are finite fields of order $q$, with $q$ prime, and rings of the form $\\mathbb{Z}_{2^k}$. A special case is the field $\\mathbb{Z}_2$, which is the one that we refer to as binary domain. For the cases where the field has order $q  2$ and $\\mathbb{Z}_{2^k}$ with $k  1$, we refer to them as arithmetic domains.\nEach domain has its advantages for some given tasks. For example, arithmetic domains are widely used in tasks where there are a significant amount of integer operations such as computing statistics over some dataset. On the other hand, binary domains are preferred when there is a significant amount of operations that go down to a bit level of computation, for example, in integer comparisons and bit-wise operations (Damgård et al., 2019). However, some applications need the advantages of both worlds to achieve a better performance. For example, one may think of a program that needs a huge amount of bit-level computations but also needs to perform arithmetic computations between secret integers. In this case, a solution that fits better for this situation is a mixed-circuit computation.\nIn this blog post, we will see how to make the transition from secret values shared in a binary domain to shares in an arithmetic domain using daBits, and how to implement this in the MP-SDPZ framework. The purpose of this blog post is not to explain the underlying protocols to generate daBits given that it is a very extensive topic (such content may be a blog post by itself). Instead, we will explain briefly what are daBits along a basic protocol to do the domain conversion, and finally how to do this using the mentioned framework above.\nThis blog assumes that the reader is familiar with the following concepts: basic concepts on MPC, secret-sharing schemes, and MP-SDPZ basics (see the tutorial and the documentation of the framework). Also, it would be desirable previous exposure to daBits, although it is not completely needed given that I will present a very high-level definition.\nNotation This blog post assumes that we are using general-purpose protocols based on linear secret-sharing schemes (SS) that realize an arithmetic black box functionality. This means that the protocols that we are considering allow the secure computation of additions and multiplications. We denote $\\llbracket x \\rrbracket \\stackrel{\\text{def}}{=} (x_1, x_2, \\dots x_n)$ as the shares of a secret value $x$. Given that we are dealing with mixed-circuit computation, we denote $\\llbracket x \\rrbracket_2$ as a binary sharing of $x \\in \\mathbb{Z}_2$, meaning that all the shares $x_1, \\dots, x_n$ are in $\\mathbb{Z}_2$. Without loss of generality, we will consider that the arithmetic domain that we will use is $\\mathbb{Z}_q$, for $q  2$ a prime number. In this case, we write $\\llbracket x \\rrbracket_q$ meaning that the shares $x_1, \\dots, x_n$ are in $\\mathbb{Z}_q$.\nWith this notation, the goal of this blog post is to explain how to convert $\\llbracket x \\rrbracket_2$ into a sharing $\\llbracket x \\rrbracket_q$ for a given value $x \\in \\mathbb{Z}_2$.\ndaBits and domain conversion According to Rotaru \u0026 Wood (2019) and Aly et al. (2019), a daBit (which stands for double authenticated bit) is a tuple of the form $(\\llbracket r \\rrbracket_2, \\llbracket r \\rrbracket_q)$, where $r \\in \\mathbb{Z}_2$ is a random bit that is unknown to all the parties participating in the protocol. Notice that, although the underlying shared value $r$ is the same in both the binary sharing and the arithmetic sharing, the shares in each case are not necessarily equal. Consider for example a protocol based on an additive secret-sharing scheme for 3 parties, and $q = 23$. If $r = 1$, it may happen that $\\llbracket r \\rrbracket_2 = (0, 0, 1)$ and $\\llbracket r \\rrbracket_q = (18, 5, 1)$. In both cases, the sum of all the shares in their corresponding algebraic structure is $r = 1$, but the underlying shares are completely different.\nGiven that the underlying value in a daBit is chosen at random and does not depend on the inputs provided by the parties, those daBits can be generated in a preprocessing stage of the protocol, that is, the daBits can be generated before each party provides its input to the protocol execution.\nFor a complete specification of a protocol that generates daBits, I refer the reader to the works of Rotaru \u0026 Wood (2019) and Aly et al. (2019).\nAssuming that we can securely generate daBits, we can use them to design a protocol to convert binary shares into arithmetic shares. A protocol to accomplish this task, taken from Damgård (2019), works as follows:\nInput: a sharing $\\llbracket x \\rrbracket_2$ for $x \\in \\mathbb{Z}_2$.\nOutput: a sharing $\\llbracket x \\rrbracket_q$\n Get a fresh daBit $(\\llbracket r \\rrbracket_2, \\llbracket r \\rrbracket_q)$ generated in the preprocessing phase. Each party computes locally $\\llbracket c \\rrbracket_2 = \\llbracket x \\rrbracket_2 + \\llbracket r \\rrbracket_2$. The parties reveal and learn the value of $c$. The parties compute locally $\\llbracket x \\rrbracket_q = c - \\llbracket r \\rrbracket_q$. The protocol outputs $\\llbracket x \\rrbracket_q$.  Looking at the protocol specification, in Step 3, the parties reveal $c$ but its value does not reveal anything about the value of $x$ because $r$ acts as a one-time pad. Also, the round complexity of this protocol is 1 round.\nHow to do it in MP-SDPZ Now that I have introduced some concepts, I will present how to transform shares from a binary domain to an arithmetic domain using daBits under the MP-SDPZ framework. The MP-SDPZ framework is a software to benchmark multiple MPC protocols under the same ground (Keller, 2020). This framework is particularly useful to determine which techniques are best suited for a given task that needs to be computed securely. At a high level, the developer writes the functionality in language derived from Python 3; then, the software compiles the source code into a bytecode that is run by a virtual machine.\nGiven that the source code is passed through a compiler, in some situations, the compiler automatically detects when it is appropriate to use daBits. Consider the following example:\nprogram.use_edabit(True) a = sint.get_input_from(0) b = sint.get_input_from(1) c = (a  b) print_ln(\"%s\", c.reveal()) This program is the specification of a two-party protocol. The party $P_1$ provides an integer $a$ and the party $P_2$ provides an integer $b$. The program computes securely the following functionality: if $a If we compile the previous program, we obtain the following output on the terminal:\nProgram requires at most: 1 integer inputs from player 0 1 integer inputs from player 1 1 strict edabits of length 41 1 strict edabits of length 64 120 bit triples 1 integer dabits 19 virtual machine rounds Note that the compilation process shows that the protocol requires the production of an integer daBit in the pre-processing phase.\nIn the previous example, the need for a daBit automatically comes from the compilation process, however, I am more interested in showing how to tell the MP-SPDZ framework that we want to make a conversion using daBits explicitly. To do this, I will use the following source code as an example:\n# This line tells the compiler that we allow the use of daBits/edaBits. program.use_edabit(True) # Here, we are saying that the bit strings that we are manipulating in the # binary domain have just one bit. sb = sbits.get_type(1) # Parties' inputs a = sb.get_input_from(0) b = sb.get_input_from(1) c = sint.get_input_from(3) # Computation of the XOR xor = a.bit_xor(b) # Explicit domain conversion. We are converting xor from the binary domain into # the arithmetic domain. xor_int = sint(xor) # Secure multiplication result = xor_int * c # Delivering the results to all parties. print_ln(\"%s\", result.reveal()) First, let me explain the functionality presented above. The previous source code is the specification of a three-party protocol in which $P_1$ and $P_2$ provide two bits $a, b \\in \\mathbb{Z}_2$ respectively, and $P_3$ provides a value $c \\in \\mathbb{Z}_q$ for a given fixed prime $q$. It is important to mention that $c$ could belong to any arithmetic domain, but I choose $Z_q$ for this discussion. In this example, the parties agree on computing the following function securely:\n$$ f(a, b, c) = \\begin{cases} c, \u0026 \\text{if $a \\neq b$} \\\\ 0, \u0026 \\text{if $a = b$} \\end{cases} $$\nIn the protocol, the parties first compute securely $\\llbracket x \\rrbracket_2 = \\llbracket a \\rrbracket_2 \\oplus \\llbracket b \\rrbracket_2$ in the binary domain. Then, using daBits, the parties transform $\\llbracket x \\rrbracket_2$ into $\\llbracket x \\rrbracket_q$. Finally, the parties compute securely $\\llbracket r \\rrbracket_q = \\llbracket x \\rrbracket_q \\cdot \\llbracket c \\rrbracket_q$ and reveal the value $r$.\nIn the source code, each line is explained line-by-line. The relevant instruction is xor_int = sint(xor). Here, I am telling the compiler that I need an explicit conversion of the variable xor from the binary domain to the arithmetic domain. Once this instruction is computed, the parties will have shares of the value $a \\oplus b$ but in the arithmetic domain. The conversion allows the secure multiplication between $a \\oplus b$ and $c$ in the arithmetic domain.\nAs a closing remark, the examples presented here can be a bit easy and somewhat artificial. However, these concepts and techniques have real uses in more complex protocols. As an example (and a bit of self-promotion), the work of Vanegas et al. (2023) presents a two-party protocol that computes the edit distance securely using a mixed-circuit computation. First, the protocol in that paper computes some comparisons in the binary domain, and then the result of such comparisons is transformed into the arithmetic domain to finally compute the edit distance between two strings in a finite alphabet. To make the transition between the arithmetic domain to the binary domain, the authors use the techniques presented here.\nReferences  Aly, A., Orsini, E., Rotaru, D., Smart, N. P., \u0026 Wood, T. (2019). Zaphod: Efficiently Combining LSSS and Garbled Circuits in SCALE. Proceedings of the 7th ACM Workshop on Encrypted Computing \u0026 Applied Homomorphic Cryptography, 33–44. Presented at the London, United Kingdom. doi:10.1145/3338469.3358943. Damgård, I., Escudero, D., Frederiksen, T., Keller, M., Scholl, P., \u0026 Volgushev, N. (2019). New Primitives for Actively-Secure MPC over Rings with Applications to Private Machine Learning. 2019 IEEE Symposium on Security and Privacy (SP), 1102–1120. doi:10.1109/SP.2019.00078. Keller, M. (2020). MP-SPDZ: A Versatile Framework for Multi-Party Computation. Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security. doi:10.1145/3372297.3417872. Rotaru, D., \u0026 Wood, T. (2019). MArBled Circuits: Mixing Arithmetic and Boolean Circuits with Active Security. In F. Hao, S. Ruj, \u0026 S. Sen Gupta (Eds.), Progress in Cryptology – INDOCRYPT 2019 (pp. 227–249). Cham: Springer International Publishing. Vanegas, H., Cabarcas, D., \u0026 Aranha, D. F. (2023). Privacy-Preserving Edit Distance Computation Using Secret-Sharing Two-Party Computation. Progress in Cryptology – LATINCRYPT 2023: 8th International Conference on Cryptology and Information Security in Latin America, LATINCRYPT 2023, Quito, Ecuador, October 3–6, 2023, Proceedings, 67–86. Presented at the Quito, Ecuador. doi:10.1007/978-3-031-44469-2_4.  ","wordCount":"1866","inLanguage":"en","datePublished":"2023-10-31T00:00:00Z","dateModified":"2023-10-31T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://hdvanegasm.github.io/posts/dabits_and_domain_conversion/dabits/"},"publisher":{"@type":"Organization","name":"Hernán Vanegas","logo":{"@type":"ImageObject","url":"http://hdvanegasm.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://hdvanegasm.github.io/ accesskey=h title="Hernán Vanegas (Alt + H)">Hernán Vanegas</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://hdvanegasm.github.io/posts/ title="Blog posts">
<span>Blog posts</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
daBits and Domain Conversion in MP-SPDZ
</h1>
<div class=post-meta><span title="2023-10-31 00:00:00 +0000 UTC">October 31, 2023</span>&nbsp;|&nbsp;<a href=https://github.com/hdvanegasm/hdvanegasm.github.io/tree/master/content/posts/dabits_and_domain_conversion/dabits.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content><p>In secure multi-party computation (MPC), each protocol has an underlying domain of computation in which the secure operations are performed. Such domains of computation are algebraic structures such as fields or rings. Some common examples for those domains are finite fields of order $q$, with $q$ prime, and rings of the form $\mathbb{Z}_{2^k}$. A special case is the field $\mathbb{Z}_2$, which is the one that we refer to as <em>binary domain</em>. For the cases where the field has order $q > 2$ and $\mathbb{Z}_{2^k}$ with $k > 1$, we refer to them as <em>arithmetic domains</em>.</p>
<p>Each domain has its advantages for some given tasks. For example, arithmetic domains are widely used in tasks where there are a significant amount of integer operations such as computing statistics over some dataset. On the other hand, binary domains are preferred when there is a significant amount of operations that go down to a bit level of computation, for example, in integer comparisons and bit-wise operations (Damgård et al., 2019). However, some applications need the advantages of both worlds to achieve a better performance. For example, one may think of a program that needs a huge amount of bit-level computations but also needs to perform arithmetic computations between secret integers. In this case, a solution that fits better for this situation is a <em>mixed-circuit computation</em>.</p>
<p>In this blog post, we will see how to make the transition from secret values shared in a binary domain to shares in an arithmetic domain using daBits, and how to implement this in the MP-SDPZ framework. The purpose of this blog post is not to explain the underlying protocols to generate daBits given that it is a very extensive topic (such content may be a blog post by itself). Instead, we will explain briefly what are daBits along a basic protocol to do the domain conversion, and finally how to do this using the mentioned framework above.</p>
<p>This blog assumes that the reader is familiar with the following concepts: basic concepts on MPC, secret-sharing schemes, and MP-SDPZ basics (see the tutorial and the documentation of the framework). Also, it would be desirable previous exposure to daBits, although it is not completely needed given that I will present a very high-level definition.</p>
<h3 id=notation>Notation<a hidden class=anchor aria-hidden=true href=#notation>#</a></h3>
<p>This blog post assumes that we are using general-purpose protocols based on linear secret-sharing schemes (SS) that realize an arithmetic black box functionality. This means that the protocols that we are considering allow the secure computation of additions and multiplications. We denote $\llbracket x \rrbracket \stackrel{\text{def}}{=} (x_1, x_2, \dots x_n)$ as the shares of a secret value $x$. Given that we are dealing with mixed-circuit computation, we denote $\llbracket x \rrbracket_2$ as a binary sharing of $x \in \mathbb{Z}_2$, meaning that all the shares $x_1, \dots, x_n$ are in $\mathbb{Z}_2$. Without loss of generality, we will consider that the arithmetic domain that we will use is $\mathbb{Z}_q$, for $q > 2$ a prime number. In this case, we write $\llbracket x \rrbracket_q$ meaning that the shares $x_1, \dots, x_n$ are in $\mathbb{Z}_q$.</p>
<p>With this notation, the goal of this blog post is to explain how to convert $\llbracket x \rrbracket_2$ into a sharing $\llbracket x \rrbracket_q$ for a given value $x \in \mathbb{Z}_2$.</p>
<h2 id=dabits-and-domain-conversion>daBits and domain conversion<a hidden class=anchor aria-hidden=true href=#dabits-and-domain-conversion>#</a></h2>
<p>According to Rotaru & Wood (2019) and Aly et al. (2019), a <em>daBit</em> (which stands for <strong>d</strong>ouble <strong>a</strong>uthenticated <strong>bit</strong>) is a tuple of the form $(\llbracket r \rrbracket_2, \llbracket r \rrbracket_q)$, where $r \in \mathbb{Z}_2$ is a random bit that is unknown to all the parties participating in the protocol. Notice that, although the underlying shared value $r$ is the same in both the binary sharing and the arithmetic sharing, the shares in each case are not necessarily equal. Consider for example a protocol based on an additive secret-sharing scheme for 3 parties, and $q = 23$. If $r = 1$, it may happen that $\llbracket r \rrbracket_2 = (0, 0, 1)$ and $\llbracket r \rrbracket_q = (18, 5, 1)$. In both cases, the sum of all the shares in their corresponding algebraic structure is $r = 1$, but the underlying shares are completely different.</p>
<p>Given that the underlying value in a daBit is chosen at random and does not depend on the inputs provided by the parties, those daBits can be generated in a preprocessing stage of the protocol, that is, the daBits can be generated before each party provides its input to the protocol execution.</p>
<p>For a complete specification of a protocol that generates daBits, I refer the reader to the works of Rotaru & Wood (2019) and Aly et al. (2019).</p>
<p>Assuming that we can securely generate daBits, we can use them to design a protocol to convert binary shares into arithmetic shares. A protocol to accomplish this task, taken from Damgård (2019), works as follows:</p>
<p><strong>Input:</strong> a sharing $\llbracket x \rrbracket_2$ for $x \in \mathbb{Z}_2$.</p>
<p><strong>Output:</strong> a sharing $\llbracket x \rrbracket_q$</p>
<ol>
<li>Get a fresh daBit $(\llbracket r \rrbracket_2, \llbracket r \rrbracket_q)$ generated in the preprocessing phase.</li>
<li>Each party computes locally $\llbracket c \rrbracket_2 = \llbracket x \rrbracket_2 + \llbracket r \rrbracket_2$.</li>
<li>The parties reveal and learn the value of $c$.</li>
<li>The parties compute locally $\llbracket x \rrbracket_q = c - \llbracket r \rrbracket_q$.</li>
<li>The protocol outputs $\llbracket x \rrbracket_q$.</li>
</ol>
<p>Looking at the protocol specification, in Step 3, the parties reveal $c$ but its value does not reveal anything about the value of $x$ because $r$ acts as a one-time pad. Also, the round complexity of this protocol is 1 round.</p>
<h2 id=how-to-do-it-in-mp-sdpz>How to do it in MP-SDPZ<a hidden class=anchor aria-hidden=true href=#how-to-do-it-in-mp-sdpz>#</a></h2>
<p>Now that I have introduced some concepts, I will present how to transform shares from a binary domain to an arithmetic domain using daBits under the MP-SDPZ framework. The MP-SDPZ framework is a software to benchmark multiple MPC protocols under the same ground (Keller, 2020). This framework is particularly useful to determine which techniques are best suited for a given task that needs to be computed securely. At a high level, the developer writes the functionality in language derived from Python 3; then, the software compiles the source code into a <em>bytecode</em> that is run by a virtual machine.</p>
<p>Given that the source code is passed through a compiler, in some situations, the compiler automatically detects when it is appropriate to use daBits. Consider the following example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>program<span style=color:#f92672>.</span>use_edabit(<span style=color:#66d9ef>True</span>)

a <span style=color:#f92672>=</span> sint<span style=color:#f92672>.</span>get_input_from(<span style=color:#ae81ff>0</span>)
b <span style=color:#f92672>=</span> sint<span style=color:#f92672>.</span>get_input_from(<span style=color:#ae81ff>1</span>)

c <span style=color:#f92672>=</span> (a <span style=color:#f92672>&lt;</span> b)

print_ln(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span>, c<span style=color:#f92672>.</span>reveal())
</code></pre></div><p>This program is the specification of a two-party protocol. The party $P_1$ provides an integer $a$ and the party $P_2$ provides an integer $b$. The program computes securely the following functionality: if $a &lt; b$, the protocol outputs 1 to both parties, otherwise it outputs 0.</p>
<p>If we compile the previous program, we obtain the following output on the terminal:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext>Program requires at most:
           1 integer inputs from player 0
           1 integer inputs from player 1
           1 strict edabits of length 41
           1 strict edabits of length 64
         120 bit triples
           1 integer dabits
          19 virtual machine rounds
</code></pre></div><p>Note that the compilation process shows that the protocol requires the production of an integer daBit in the pre-processing phase.</p>
<p>In the previous example, the need for a daBit automatically comes from the compilation process, however, I am more interested in showing how to tell the MP-SPDZ framework that we want to make a conversion using daBits explicitly. To do this, I will use the following source code as an example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># This line tells the compiler that we allow the use of daBits/edaBits.</span>
program<span style=color:#f92672>.</span>use_edabit(<span style=color:#66d9ef>True</span>)

<span style=color:#75715e># Here, we are saying that the bit strings that we are manipulating in the</span>
<span style=color:#75715e># binary domain have just one bit.</span>
sb <span style=color:#f92672>=</span> sbits<span style=color:#f92672>.</span>get_type(<span style=color:#ae81ff>1</span>)

<span style=color:#75715e># Parties&#39; inputs</span>
a <span style=color:#f92672>=</span> sb<span style=color:#f92672>.</span>get_input_from(<span style=color:#ae81ff>0</span>)
b <span style=color:#f92672>=</span> sb<span style=color:#f92672>.</span>get_input_from(<span style=color:#ae81ff>1</span>)
c <span style=color:#f92672>=</span> sint<span style=color:#f92672>.</span>get_input_from(<span style=color:#ae81ff>3</span>)

<span style=color:#75715e># Computation of the XOR</span>
xor <span style=color:#f92672>=</span> a<span style=color:#f92672>.</span>bit_xor(b)

<span style=color:#75715e># Explicit domain conversion. We are converting xor from the binary domain into</span>
<span style=color:#75715e># the arithmetic domain.</span>
xor_int <span style=color:#f92672>=</span> sint(xor)

<span style=color:#75715e># Secure multiplication</span>
result <span style=color:#f92672>=</span> xor_int <span style=color:#f92672>*</span> c

<span style=color:#75715e># Delivering the results to all parties.</span>
print_ln(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span>, result<span style=color:#f92672>.</span>reveal())
</code></pre></div><p>First, let me explain the functionality presented above. The previous source code is the specification of a three-party protocol in which $P_1$ and $P_2$ provide two bits $a, b \in \mathbb{Z}_2$ respectively, and $P_3$ provides a value $c \in \mathbb{Z}_q$ for a given fixed prime $q$. It is important to mention that $c$ could belong to any arithmetic domain, but I choose $Z_q$ for this discussion. In this example, the parties agree on computing the following function securely:</p>
<p>$$
f(a, b, c) =
\begin{cases}
c, & \text{if $a \neq b$} \\
0, & \text{if $a = b$}
\end{cases}
$$</p>
<p>In the protocol, the parties first compute securely $\llbracket x \rrbracket_2 = \llbracket a \rrbracket_2 \oplus \llbracket b \rrbracket_2$ in the binary domain. Then, using daBits, the parties transform $\llbracket x \rrbracket_2$ into $\llbracket x \rrbracket_q$. Finally, the parties compute securely $\llbracket r \rrbracket_q = \llbracket x \rrbracket_q \cdot \llbracket c \rrbracket_q$ and reveal the value $r$.</p>
<p>In the source code, each line is explained line-by-line. The relevant instruction is <code>xor_int = sint(xor)</code>. Here, I am telling the compiler that I need an explicit conversion of the variable <code>xor</code> from the binary domain to the arithmetic domain. Once this instruction is computed, the parties will have shares of the value $a \oplus b$ but in the arithmetic domain. The conversion allows the secure multiplication between $a \oplus b$ and $c$ in the arithmetic domain.</p>
<p>As a closing remark, the examples presented here can be a bit easy and somewhat artificial. However, these concepts and techniques have real uses in more complex protocols. As an example (and a bit of self-promotion), the work of Vanegas et al. (2023) presents a two-party protocol that computes the edit distance securely using a mixed-circuit computation. First, the protocol in that paper computes some comparisons in the binary domain, and then the result of such comparisons is transformed into the arithmetic domain to finally compute the edit distance between two strings in a finite alphabet. To make the transition between the arithmetic domain to the binary domain, the authors use the techniques presented here.</p>
<h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2>
<ul>
<li>Aly, A., Orsini, E., Rotaru, D., Smart, N. P., & Wood, T. (2019). Zaphod: Efficiently Combining LSSS and Garbled Circuits in SCALE. Proceedings of the 7th ACM Workshop on Encrypted Computing & Applied Homomorphic Cryptography, 33–44. Presented at the London, United Kingdom. doi:10.1145/3338469.3358943.</li>
<li>Damgård, I., Escudero, D., Frederiksen, T., Keller, M., Scholl, P., & Volgushev, N. (2019). New Primitives for Actively-Secure MPC over Rings with Applications to Private Machine Learning. 2019 IEEE Symposium on Security and Privacy (SP), 1102–1120. doi:10.1109/SP.2019.00078.</li>
<li>Keller, M. (2020). MP-SPDZ: A Versatile Framework for Multi-Party Computation. Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security. doi:10.1145/3372297.3417872.</li>
<li>Rotaru, D., & Wood, T. (2019). MArBled Circuits: Mixing Arithmetic and Boolean Circuits with Active Security. In F. Hao, S. Ruj, & S. Sen Gupta (Eds.), Progress in Cryptology &ndash; INDOCRYPT 2019 (pp. 227–249). Cham: Springer International Publishing.</li>
<li>Vanegas, H., Cabarcas, D., & Aranha, D. F. (2023). Privacy-Preserving Edit Distance Computation Using Secret-Sharing Two-Party Computation. Progress in Cryptology – LATINCRYPT 2023: 8th International Conference on Cryptology and Information Security in Latin America, LATINCRYPT 2023, Quito, Ecuador, October 3–6, 2023, Proceedings, 67–86. Presented at the Quito, Ecuador. doi:10.1007/978-3-031-44469-2_4.</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=http://hdvanegasm.github.io/>Hernán Vanegas</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>